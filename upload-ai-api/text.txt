Transcrição do vídeo:
Fala, galera! Beleza? Mais um vídeo aqui para o canal do YouTube da Rocketseat. Para hoje, a gente vai falar um dos erros mais comuns de quem está iniciando no React, que é a criação de derived states. E calma, se você não entendeu o que é isso, porque eu vou te mostrar aqui no código agora, então bora codar para a gente ver o que é isso. Eu já deixei aqui previamente um projeto criado bem simples, um projeto criado com o Vite, para a gente não partir do total zero e poder ir direto ao assunto aqui. Eu vou mostrar um pouquinho o que é esse erro que muita gente comete, e eu vejo isso em projetos de pessoas de todos os níveis, para ser bem sincero, em React. Porque ele tem várias formas de ser cometido, mas eu vou te mostrar como evitar isso e como pensar na hora de criação de um novo estado no React, como que a gente pode pensar de uma maneira mais performática aqui dentro. Então vamos lá! Dando uma analisada aqui um pouquinho na aplicação que a gente tem, para a gente entender o que vai ser feito, veja só, eu tenho um único componente app, é esse componente que está sendo exibido aqui em tela. Esse componente tem um estado que armazena uma lista de repositórios. Até aí tudo bem. Então, eu tenho toda a lista de repositórios, aqui eu criei uma tipagem do TypeScript para essa lista... Eu estou falando que cada repositório tem nome e description... É claro que tem muito mais, mas eu coloquei só essas duas informações para a gente usá-las... Eu inicio isso como um array vazio... E aí, eu utilizo um useEffect do React, para assim que esse componente for exibido em tela, ele busca da API do GitHub os meus repositórios, aqui você pode colocar o seu usuário do GitHub, caso você tenha uma lista grande de repositórios para trazer do seu usuário... E aí, eu salvo, converto isso aqui em JSON e salvo isso dentro do meu estado. E aí, o que eu faço? Aqui embaixo, dentro do HTML, do JSX, eu basicamente percorro por essa lista com um map, e para cada repositório eu mostro um li contendo o nome daquele repositório. Ou seja, é muito simples a aplicação que a gente criou aqui, mas ela abre brecha para a gente errar em várias coisinhas simples quando a gente for colocar mais funcionalidades. Então, vamos lá... Primeira coisa aqui... Imagina que eu queira adicionar um filtro nessa lista. Ou seja, aqui em cima eu coloquei um input e eu quero que conforme o usuário vá digitando nesse input, eu quero filtrar a lista. Muito simples. Então, vamos lá... Primeiramente, eu preciso anotar, saber o que o usuário digitou dentro desse input aqui. Então, no React, a gente tem muitas formas de fazer isso. A forma mais comum de a gente fazer é criando aqui um estado... Vou chamar ele de search... Vou começar ele com uma string vazia... E aí, aqui embaixo, toda vez que o usuário digitar alguma coisa dentro do input, eu vou pegar o evento e vou dar um setSearch como o valor desse input. E aqui, o value dele vai ser o próprio search, caso a gente queira limpar esse campo. E aí, tudo bem. Agora, o que eu quero fazer? Toda vez que o usuário mudar o valor de search, eu quero que a lista em si seja filtrada. E aí, muita gente vai cometer já um primeiro erro agora, que é usar um useEffect para isso. E aí, eu vou começar errando em todos os pontos e depois a gente vai corrigindo aos poucos. Então, a gente vê lá quando a gente aprende sobre React, que com o useEffect, eu consigo disparar uma função toda vez que uma variável muda, correto? Correto. Então, toda vez que o valor de search mudar, eu vou calcular um novo valor para uma lista filtrada. Então, vamos lá. Eu vou criar agora um novo estado chamado de filteredRepos, que tem aqui também um array vazio que vai salvar uma lista de repositórios. E aqui dentro desse useEffect, eu vou dar um setFilteredRepos, como sendo agora a minha lista de repositórios original, porém filtrada, procurando por onde o nome do repositório inclua o que eu digitei na busca. E agora, aqui embaixo na minha ul, eu vou fazer o seguinte... Se o meu filteredRepos.length for maior... Ou melhor, se o meu search.length for maior que zero, ou seja, existir alguma coisa aqui na busca, eu vou mostrar a minha ul, porém ela vai mostrar os repositórios filtrados. Se não, aqui embaixo eu vou mostrar a ul, porém eu vou mostrar os repositórios originais, onde eu não tenho os repositórios filtrados. Vou salvar isso aqui agora e vamos lá. Eu tenho aqui a minha lista de repositórios e agora se eu digitar aqui, por exemplo, next, olha só... Conforme eu vou digitando, ele vai filtrando a lista. E está 100%, né? Está 100%, está funcionando. Mas como a gente pode melhorar esse código ainda mais? Veja só, primeiramente, quais são os problemas que a gente tem aqui, tá? Eu vou começar colocando um console.log aqui dentro, escrito renderizou, né? Renderizou, para quem já vem do ecossistema de conhecimento do React, já sabe que renderizar é o ato do React recalcular todo o conteúdo de um componente. E isso acontece quando ou um hook muda, um estado, por exemplo, muda, ou uma propriedade daquele componente muda, ou um elemento pai daquele componente é alterado, assim desencadeando uma renderização em todos os seus componentes filhos. Eu vou salvar isso aqui agora e olha que interessante. Eu venho aqui agora no nava console do meu navegador e eu vou dar um F5, tá? E aí tem um pontinho aqui que eu quero evitar, só para não confundir a gente, que a gente pode ver que ele está mostrando, renderizou aqui um cinza mais clarinho. Isso é por causa do strict mode do React, que em desenvolvimento ele faz tudo repetir, pelo menos uma vez. Então, só para a gente não se perder com isso, eu vou comentar o strict mode, mas não precisa se preocupar, esse strict mode pode ficar habilitado até porque em produção não vai ter problema nenhum. Eu vou salvar isso aqui agora e pronto. A gente pode ver que assim que eu coloquei o componente em tela, eu já vi três vezes o renderizou, ou seja, esse componente já renderizou três vezes. Claro, a primeira vez porque foi o componente sendo exibido em tela, a segunda vez porque quando esse useEffect terminou de buscar os repositórios do GitHub, ele preencheu a variável setRepos, então ele já preencheu o valor e causou uma renderização. E esse outro useEffect aqui, mesmo que search não tenha nenhum valor dentro, ele executou também, porque a gente não está criando nenhum tipo de verificação aqui. Caso eu gostaria de evitar uma renderização aqui dentro, eu posso verificar se existe alguma coisa dentro do input de search, aí sim eu rodo essa atualização de estado. Isso aqui já vai fazer com que eu evite uma renderização, então eu vejo que agora eu só tenho duas renderizações aqui dentro. Mas o problema nem era esse, eu só quis arrumar isso aqui agora para desencargo, mas o problema maior é o seguinte... Veja só o que acontece assim que eu digitar a tecla N aqui dentro do input, para procurar por repositórios que têm essa letra no nome. Eu vou até limpar o console aqui e vou apertar N. Ele renderizou duas vezes. Por que ele renderizou duas vezes? Vamos acompanhar junto comigo. Primeiro, quando o meu input trocou o valor, quando o usuário digitou um novo valor dentro do input, eu preenchi o meu estado de search com o valor digitado. Quando eu preencho um novo estado no React, ele causa uma nova renderização. Nessa nova renderização, o React percebeu através desse useEffect que então o meu valor do search mudou. E aí, ele viu que tinha um texto digitado dentro do search, ou seja, o length é maior que zero, e ele rodou novamente uma atualização de estado, salvando dentro do filtered repos a minha listagem de repositórios filtrada, causando uma nova renderização. E é aí o ponto que eu queria chegar. Isso aqui são estados derivados. E qual é a maneira de eu resolver isso aqui? Eu vou começar comentando esse useEffect e comentar também esse estado de repositórios filtrados. E a gente vai utilizar agora simplesmente uma variável que contém os nossos repositórios filtrados. E essa variável vai ser o seguinte... Se algo existir dentro de search, ou seja, o length for maior que zero, essa variável aqui vai ser os meus repositórios filtrados, onde o repo.name inclui a minha busca. Se não, vai ser um array vazio. E agora, acabou. É isso. Eu vou salvar. E agora, quando eu digitar N dentro do input... Opa, eu apaguei o console.log aqui do renderizou. Salvo. Quando eu digito N, ele só deu mais um renderizou aqui. Ele só mostrou uma única vez. Por quê? Porque o React agora só precisou renderizar este componente novamente quando eu chamei o setSearch aqui de dentro do meu input. E depois disso, o valor dos repositórios filtrados não precisa ficar dentro de um novo estado. Eles podem ser calculados dentro do componente como uma variável. E por mais que isso aqui pareça besta, muito besta, muita gente comete o erro de criar estados derivados. E aqui está muito simples visualizar, porque isso aqui é uma lista. Mas algumas vezes, isso pode estar de outras formas. Por exemplo, imagina que eu tenha algum tipo de seleção para o usuário. E aí, eu tenho que armazenar a lista de possíveis opções que o usuário tem para selecionar... E aí, eu tenho lá um estado, por exemplo, que eu quero salvar qual é a seleção que o usuário escolheu. Às vezes, eu não preciso salvar a opção que o usuário selecionou. Eu posso salvar só o id e criar uma variável aqui dentro que seja derivada desses estados anteriores, que cria qual foi a opção selecionada pelo usuário. Mas dentro aqui de derived states, isso aqui às vezes pode caminhar também para propriedades. Então, é muito comum, por exemplo, às vezes a gente ter uma propriedade que a gente passa para um componente, por exemplo, que é uma lista. E essa lista tem lá 1, 2, 3, 4 e 5, por exemplo. E aí, eu tenho aqui que falar que o meu app agora recebe uma lista de números como propriedade. E aí, o que eu vejo muita gente fazer também é... Bom, se eu preciso filtrar essa lista agora, eu vou criar então um estado chamado filteredList, que vai filtrar essa lista. Novamente, a gente não precisa. A gente pode criar simplesmente uma variável que busca aqui do valor da propriedade list e faz a filtragem aqui direto de dentro do próprio React, evitando algumas renderizações desnecessárias. Então, basicamente, o vídeo que eu queria trazer hoje para você era esse. Então, comenta aqui embaixo, inclusive, se você já caiu nessa problemática de criação de estados derivados. Se você acha que nunca caiu, pega algum repositório que você trabalha diariamente com React, dá uma olhada, porque às vezes eu pego alguns repositórios de gente que trabalha com React há muito tempo, dou uma olhada e eu vejo essa problemática acontecendo, porque às vezes a gente faz sem querer. Então, dá uma olhadinha aí embaixo. Inclusive, comenta aqui embaixo qual o tema que você está utilizando no seu VSCode ultimamente, porque nessa aula eu gravei com Shades of Purple, mas eu fico trocando de tema diariamente até porque eu acho que aumenta a minha criatividade. Não sei, eu posso estar muito louco, mas comigo acontece isso. Então, não esquece de deixar o like e comentar aí embaixo e a gente se vê aí na próxima aula. Um grande abraço e valeu!

Resumo feito pela IA:
Neste vídeo, o apresentador aborda um erro comum cometido por iniciantes em React, que é a criação de estados derivados. Ele mostra um exemplo de um componente que possui um estado que armazena uma lista de repositórios e explica como adicionar um filtro a essa lista. O apresentador demonstra inicialmente a forma incorreta de fazer isso, utilizando o useEffect para atualizar um estado de repositórios filtrados. Em seguida, ele mostra como melhorar o código, utilizando uma variável para armazenar os repositórios filtrados, evitando renderizações desnecessárias. O vídeo ressalta a importância de evitar a criação de estados derivados e sugere que os espectadores verifiquem seus próprios projetos em React para identificar possíveis problemas semelhantes. O apresentador também menciona o tema do VSCode que ele está usando e encerra o vídeo pedindo aos espectadores que deixem um like e comentem sobre o tema que estão utilizando.